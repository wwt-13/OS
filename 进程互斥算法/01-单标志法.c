// 以全局变量turn来决定谁进入临界区
// 当turn=x时，进程号为x的进程进入临界区
int turn;
int main()
{
    while (turn != x)
        ;
    critical_section;
    turn = other;
}
/* 算法分析
确实实现了互斥,但是违背了空闲让进、让权等待等原则
假如现在有进程p0,p1
此时turn初始为0，代表首先轮到p0访问临界资源
但是目前临界区一直处于空闲状态，如果p1先申请访问临界区的话，该申请无法被执行
明明临界区空闲却无法访问，这违背了空闲让进的原则
同时也违背了临界区外的进程不能干涉其他进程的准则(p0处于临界区外,但是turn使得p1无法进入临界区)
并且当p0进程在访问空闲区的时候，p1进程会在while语句中执行空循环等待，知道p0访问完毕
这违背了让权等待的原则
并且一旦某个进程被终止，就会造成其他进程的永久阻塞
 */